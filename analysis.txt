# migrations/011_add_preferences_to_users.sql
#####
-- Add preferences column to users table
ALTER TABLE public.users
ADD COLUMN IF NOT EXISTS preferences JSONB DEFAULT '{}'::jsonb;

-- Create index for preferences for faster lookups if needed (optional but good practice)
CREATE INDEX IF NOT EXISTS idx_users_preferences ON public.users USING gin (preferences);
#####

# migrations/002_conversation_state_history.sql
#####
-- ============================================================================
-- 8. CONVERSATION STATE HISTORY TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS conversation_state_history (
    history_id   TEXT PRIMARY KEY DEFAULT generate_ulid(),
    conv_id      TEXT NOT NULL REFERENCES conversations(conv_id) ON DELETE CASCADE,
    from_status  TEXT,
    to_status    TEXT NOT NULL,
    changed_by   TEXT CHECK (changed_by IN ('user', 'agent', 'system', 'supervisor', 'tool', 'support')) DEFAULT 'system',
    changed_by_id TEXT, -- ID of the user/agent/system component
    reason       TEXT,
    metadata     JSONB DEFAULT '{}'::jsonb,
    created_at   TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_conv_state_history_conv_id ON conversation_state_history(conv_id);
CREATE INDEX IF NOT EXISTS idx_conv_state_history_created_at ON conversation_state_history(created_at);
CREATE INDEX IF NOT EXISTS idx_conv_state_history_to_status ON conversation_state_history(to_status);

-- JSONB Index
CREATE INDEX IF NOT EXISTS idx_conv_state_history_metadata_gin ON conversation_state_history USING gin(metadata);

COMMENT ON TABLE conversation_state_history IS 'Audit trail for conversation status transitions';
COMMENT ON COLUMN conversation_state_history.history_id IS 'Unique ULID identifier for the history entry';
COMMENT ON COLUMN conversation_state_history.conv_id IS 'ULID reference to parent conversation';

-- Trigger for ULID generation
CREATE OR REPLACE FUNCTION set_history_id_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.history_id IS NULL THEN
        NEW.history_id := generate_ulid();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_history_ulid ON conversation_state_history;
CREATE TRIGGER trigger_history_ulid
    BEFORE INSERT ON conversation_state_history
    FOR EACH ROW
    EXECUTE FUNCTION set_history_id_on_insert();
#####

# migrations/012_drop_redundant_index.sql
#####
-- Migration: Drop redundant index on conversations table
-- Created at: 2026-02-02
-- Description: Drops idx_conversations_session_key which is identical to idx_conversations_owner_session.
-- Note: idx_conversations_owner_session is kept as it is more descriptive.

DROP INDEX IF EXISTS idx_conversations_session_key;
#####

# migrations/007_feature_relationships.sql
#####
-- ==============================================
-- Migração de Tabelas para Feature Relationships
-- ==============================================

-- ==============================================
-- Tabela: person
-- ==============================================
CREATE TABLE IF NOT EXISTS person (
    id BIGSERIAL PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    phone TEXT NOT NULL,
    tags TEXT,
    birthday DATE,
    city TEXT,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_person_name ON person(last_name, first_name);
CREATE INDEX IF NOT EXISTS idx_person_phone ON person(phone);
CREATE INDEX IF NOT EXISTS idx_person_tags ON person(tags);

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_person_updated_at
    BEFORE UPDATE ON person
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ==============================================
-- Tabela: interaction
-- ==============================================
CREATE TABLE IF NOT EXISTS interaction (
    id BIGSERIAL PRIMARY KEY,
    person_id BIGINT REFERENCES person(id) ON DELETE CASCADE,
    date TIMESTAMP WITH TIME ZONE NOT NULL,
    channel TEXT NOT NULL,
    type TEXT NOT NULL,
    summary TEXT,
    sentiment NUMERIC(3, 2), -- Ex: 0.85
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_interaction_person_id ON interaction(person_id);
CREATE INDEX IF NOT EXISTS idx_interaction_date ON interaction(date);

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_interaction_updated_at
    BEFORE UPDATE ON interaction
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ==============================================
-- Tabela: reminder
-- ==============================================
CREATE TABLE IF NOT EXISTS reminder (
    id BIGSERIAL PRIMARY KEY,
    person_id BIGINT REFERENCES person(id) ON DELETE CASCADE,
    due_date TIMESTAMP WITH TIME ZONE NOT NULL,
    reason TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'open',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_reminder_person_id ON reminder(person_id);
CREATE INDEX IF NOT EXISTS idx_reminder_due_date ON reminder(due_date);
CREATE INDEX IF NOT EXISTS idx_reminder_status ON reminder(status);

-- Trigger para atualizar updated_at automaticamente
DROP TRIGGER IF EXISTS update_reminder_updated_at ON reminder;
CREATE TRIGGER update_reminder_updated_at
    BEFORE UPDATE ON reminder
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ==============================================
-- Comentários nas tabelas
-- ==============================================
COMMENT ON TABLE person IS 'Tabela de contatos/pessoas do CRM de relacionamentos';
COMMENT ON TABLE interaction IS 'Histórico de interações com as pessoas';
COMMENT ON TABLE reminder IS 'Lembretes e tarefas relacionadas às pessoas';
#####

# migrations/purge/002_seed_data.sql
#####
-- ============================================================================
-- Owner Project - Seed Data
-- Initial data for development and testing
-- ============================================================================

-- ============================================================================
-- 1. INSERT OWNERS
-- ============================================================================
INSERT INTO owners (owner_id, name, email, created_at, active) VALUES
    (1, 'Default Organization', 'admin@example.com', NOW(), true),
    (2, 'Test Company', 'test@company.com', NOW(), true)
ON CONFLICT (email) DO NOTHING;

-- Reset sequence to continue from the highest ID
SELECT setval('owners_owner_id_seq', (SELECT COALESCE(MAX(owner_id), 1) FROM owners), true);

-- ============================================================================
-- 2. INSERT USERS
-- ============================================================================
INSERT INTO users (user_id, owner_id, profile_name, first_name, last_name, role, phone, active, created_at) VALUES
    (1, 1, 'admin', 'Admin', 'User', 'admin', '+5511999999999', true, NOW()),
    (2, 1, 'agent1', 'Agent', 'One', 'agent', '+5511988888888', true, NOW()),
    (3, 1, 'user1', 'Regular', 'User', 'user', '+5511977777777', true, NOW()),
    (4, 2, 'test_admin', 'Test', 'Admin', 'admin', '+5511966666666', true, NOW())
ON CONFLICT DO NOTHING;

-- Reset sequence
SELECT setval('users_user_id_seq', (SELECT COALESCE(MAX(user_id), 1) FROM users), true);

-- ============================================================================
-- 3. INSERT FEATURES
-- ============================================================================
INSERT INTO features (feature_id, owner_id, name, description, enabled, config_json, created_at) VALUES
    (1, 1, 'ai_chat', 'AI-powered chat responses', true, '{"model": "gpt-4", "temperature": 0.7}'::jsonb, NOW()),
    (2, 1, 'sentiment_analysis', 'Analyze message sentiment', true, '{}'::jsonb, NOW()),
    (3, 1, 'auto_routing', 'Automatic conversation routing', false, '{}'::jsonb, NOW()),
    (4, 2, 'ai_chat', 'AI-powered chat responses', true, '{"model": "gpt-3.5-turbo"}'::jsonb, NOW())
ON CONFLICT (owner_id, name) DO NOTHING;

-- Reset sequence
SELECT setval('features_feature_id_seq', (SELECT COALESCE(MAX(feature_id), 1) FROM features), true);

-- ============================================================================
-- 4. INSERT TWILIO ACCOUNTS
-- ============================================================================
INSERT INTO twilio_accounts (tw_account_id, owner_id, account_sid, auth_token, phone_numbers, created_at) VALUES
    (1, 1, 'AC_EXAMPLE_SID_1234567890', 'example_auth_token_1234567890', 
     '["+14155238886", "+14155551234"]'::jsonb, NOW()),
    (2, 2, 'AC_TEST_SID_0987654321', 'test_auth_token_0987654321',
     '["+14155555678"]'::jsonb, NOW())
ON CONFLICT DO NOTHING;

-- Reset sequence
SELECT setval('twilio_accounts_tw_account_id_seq', (SELECT COALESCE(MAX(tw_account_id), 1) FROM twilio_accounts), true);

-- ============================================================================
-- 5. INSERT SAMPLE CONVERSATIONS (optional)
-- ============================================================================
INSERT INTO conversations (
    conv_id, owner_id, user_id, from_number, to_number, 
    status, started_at, channel, phone_number, context
) VALUES
    (1, 1, 2, 'whatsapp:+5511991490733', 'whatsapp:+14155238886', 
     'progress', NOW() - INTERVAL '1 hour', 'whatsapp', '+14155238886',
     '{"customer_name": "João Silva"}'::jsonb),
    (2, 1, NULL, 'whatsapp:+5511987654321', 'whatsapp:+14155238886',
     'pending', NOW() - INTERVAL '30 minutes', 'whatsapp', '+14155238886',
     '{}'::jsonb)
ON CONFLICT DO NOTHING;

-- Reset sequence
SELECT setval('conversations_conv_id_seq', (SELECT COALESCE(MAX(conv_id), 1) FROM conversations), true);

-- ============================================================================
-- 6. INSERT SAMPLE MESSAGES (optional)
-- ============================================================================
INSERT INTO messages (
    msg_id, conv_id, from_number, to_number, body, 
    direction, timestamp, sent_by_ia, message_owner, message_type
) VALUES
    (1, 1, 'whatsapp:+5511991490733', 'whatsapp:+14155238886', 
     'Olá, preciso de ajuda', 'inbound', NOW() - INTERVAL '1 hour', false, 'user', 'text'),
    (2, 1, 'whatsapp:+14155238886', 'whatsapp:+5511991490733',
     'Olá! Como posso ajudá-lo?', 'outbound', NOW() - INTERVAL '59 minutes', true, 'agent', 'text'),
    (3, 1, 'whatsapp:+5511991490733', 'whatsapp:+14155238886',
     'Gostaria de saber sobre meu pedido', 'inbound', NOW() - INTERVAL '58 minutes', false, 'user', 'text')
ON CONFLICT DO NOTHING;

-- Reset sequence
SELECT setval('messages_msg_id_seq', (SELECT COALESCE(MAX(msg_id), 1) FROM messages), true);

-- ============================================================================
-- 7. INSERT SAMPLE AI RESULTS (optional)
-- ============================================================================
INSERT INTO ai_results (ai_result_id, msg_id, feature_id, result_json, processed_at) VALUES
    (1, 1, 1, '{"intent": "support_request", "confidence": 0.95}'::jsonb, NOW() - INTERVAL '1 hour'),
    (2, 1, 2, '{"sentiment": "neutral", "score": 0.6}'::jsonb, NOW() - INTERVAL '1 hour'),
    (3, 3, 1, '{"intent": "order_inquiry", "confidence": 0.88}'::jsonb, NOW() - INTERVAL '58 minutes')
ON CONFLICT DO NOTHING;

-- Reset sequence
SELECT setval('ai_results_ai_result_id_seq', (SELECT COALESCE(MAX(ai_result_id), 1) FROM ai_results), true);

-- ============================================================================
-- VERIFICATION QUERIES
-- ============================================================================
DO $$
DECLARE
    owner_count INTEGER;
    user_count INTEGER;
    feature_count INTEGER;
    twilio_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO owner_count FROM owners;
    SELECT COUNT(*) INTO user_count FROM users;
    SELECT COUNT(*) INTO feature_count FROM features;
    SELECT COUNT(*) INTO twilio_count FROM twilio_accounts;
    
    RAISE NOTICE '==============================================';
    RAISE NOTICE 'Seed data inserted successfully!';
    RAISE NOTICE '==============================================';
    RAISE NOTICE 'Owners: %', owner_count;
    RAISE NOTICE 'Users: %', user_count;
    RAISE NOTICE 'Features: %', feature_count;
    RAISE NOTICE 'Twilio Accounts: %', twilio_count;
    RAISE NOTICE '==============================================';
END $$;
#####

# migrations/010_message_embeddings_hybrid_search.sql
#####
-- ==========================================================
-- Hybrid Retrieval for message_embeddings (FTS + Vector + RRF)
-- ==========================================================

-- 1) Full-Text Search index (portuguese)
create index if not exists idx_message_embeddings_fts
on public.message_embeddings
using gin (to_tsvector('portuguese', coalesce(content, '')));

-- 2) Text search function
create or replace function public.search_message_embeddings_text(
  query_text text,
  match_count int,
  filter jsonb default '{}'::jsonb,
  fts_language text default 'portuguese'
)
returns table (
  id uuid,
  content text,
  metadata jsonb,
  score double precision
)
language sql
stable
as $$
  select
    me.id,
    me.content,
    me.metadata,
    ts_rank_cd(
      to_tsvector(fts_language::regconfig, coalesce(me.content, '')),
      plainto_tsquery(fts_language::regconfig, query_text)
    ) as score
  from public.message_embeddings me
  where me.metadata @> filter
    and to_tsvector(fts_language::regconfig, coalesce(me.content, ''))
      @@ plainto_tsquery(fts_language::regconfig, query_text)
  order by score desc
  limit match_count
$$;

-- 3) Hybrid search with Reciprocal Rank Fusion (RRF)
create or replace function public.search_message_embeddings_hybrid_rrf(
  query_text text,
  query_embedding vector(1536),
  match_count int,
  match_threshold double precision,
  filter jsonb default '{}'::jsonb,
  weight_vec double precision default 1.5,
  weight_text double precision default 1.0,
  rrf_k int default 60,
  fts_language text default 'portuguese'
)
returns table (
  id uuid,
  content text,
  metadata jsonb,
  score double precision
)
language sql
stable
as $$
  with v as (
    select
      me.id,
      me.content,
      me.metadata,
      row_number() over (order by me.embedding <=> query_embedding) as rnk_v
    from public.message_embeddings me
    where me.metadata @> filter
      and 1 - (me.embedding <=> query_embedding) > match_threshold
    order by me.embedding <=> query_embedding
    limit match_count
  ),
  t as (
    select
      me.id,
      me.content,
      me.metadata,
      row_number() over (
        order by ts_rank_cd(
          to_tsvector(fts_language::regconfig, coalesce(me.content, '')),
          plainto_tsquery(fts_language::regconfig, query_text)
        ) desc
      ) as rnk_t
    from public.message_embeddings me
    where me.metadata @> filter
      and to_tsvector(fts_language::regconfig, coalesce(me.content, ''))
        @@ plainto_tsquery(fts_language::regconfig, query_text)
    order by ts_rank_cd(
      to_tsvector(fts_language::regconfig, coalesce(me.content, '')),
      plainto_tsquery(fts_language::regconfig, query_text)
    ) desc
    limit match_count
  ),
  u as (
    select
      coalesce(v.id, t.id) as id,
      coalesce(v.content, t.content) as content,
      coalesce(v.metadata, t.metadata) as metadata,
      v.rnk_v,
      t.rnk_t
    from v
    full outer join t on v.id = t.id
  )
  select
    id,
    content,
    metadata,
    coalesce(weight_vec / (rrf_k + rnk_v), 0) + coalesce(weight_text / (rrf_k + rnk_t), 0) as score
  from u
  order by score desc
  limit match_count
$$;

#####

# migrations/014_security_hardening.sql
#####
-- Migration: Security Hardening (Extensions, Search Path, RLS, Views)
-- Created at: 2026-02-02
-- Description: Addresses multiple security vulnerabilities reported.

-- ============================================================================
-- 1. SECURE EXTENSIONS
-- ============================================================================
CREATE SCHEMA IF NOT EXISTS extensions;

-- Move extensions to extensions schema
-- Note: We use DO block to avoid errors if extension doesn't exist or is already moved
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'uuid-ossp' AND extnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
        ALTER EXTENSION "uuid-ossp" SET SCHEMA extensions;
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm' AND extnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
        ALTER EXTENSION "pg_trgm" SET SCHEMA extensions;
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'btree_gin' AND extnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
        ALTER EXTENSION "btree_gin" SET SCHEMA extensions;
    END IF;
    
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector' AND extnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
        ALTER EXTENSION "vector" SET SCHEMA extensions;
    END IF;
END $$;

-- Grant usage on extensions schema
GRANT USAGE ON SCHEMA extensions TO postgres, anon, authenticated, service_role;

-- Ensure functions can find extensions
ALTER DATABASE postgres SET search_path TO public, extensions;

-- ============================================================================
-- 2. FIX MUTABLE SEARCH PATHS IN FUNCTIONS
-- ============================================================================
-- We explicitly set search_path for all identified functions to prevent hijacking

ALTER FUNCTION public.search_message_embeddings_text(text, int, jsonb, text) SET search_path = public, extensions, temp;
ALTER FUNCTION public.is_valid_ulid(text) SET search_path = public, extensions, temp;
ALTER FUNCTION public.set_messages_id_on_insert() SET search_path = public, extensions, temp;
ALTER FUNCTION public.match_message_embeddings(vector, float, int, jsonb) SET search_path = public, extensions, temp;
ALTER FUNCTION public.update_updated_at_column() SET search_path = public, extensions, temp;
ALTER FUNCTION public.generate_ulid() SET search_path = public, extensions, temp;
ALTER FUNCTION public.set_conversations_id_on_insert() SET search_path = public, extensions, temp;
ALTER FUNCTION public.ulid_to_timestamp(text) SET search_path = public, extensions, temp;
ALTER FUNCTION public.set_owners_id_on_insert() SET search_path = public, extensions, temp;
ALTER FUNCTION public.search_message_embeddings_hybrid_rrf(text, vector, int, double precision, jsonb, double precision, double precision, int, text) SET search_path = public, extensions, temp;
ALTER FUNCTION public.set_ai_results_id_on_insert() SET search_path = public, extensions, temp;

-- Handle functions that might not exist in all environments (conditional logic not easily possible in pure SQL for ALTER, assuming they exist based on report)
-- If kb_hybrid_search and others exist, secure them too. 
-- Since I didn't see their definitions in the grep, I will wrap them in DO block to avoid migration failure.

DO $$
BEGIN
    BEGIN
        ALTER FUNCTION public.kb_hybrid_search(text, int, jsonb, text) SET search_path = public, extensions, temp;
    EXCEPTION WHEN OTHERS THEN NULL; END;
    
    BEGIN
        ALTER FUNCTION public.get_ulid_from_id(bigint) SET search_path = public, extensions, temp;
    EXCEPTION WHEN OTHERS THEN NULL; END;
    
    BEGIN
        ALTER FUNCTION public.kb_hybrid_union(text, int, jsonb, text) SET search_path = public, extensions, temp;
    EXCEPTION WHEN OTHERS THEN NULL; END;

    BEGIN
        ALTER FUNCTION public.get_id_from_ulid(text) SET search_path = public, extensions, temp;
    EXCEPTION WHEN OTHERS THEN NULL; END;
END $$;


-- ============================================================================
-- 3. SECURE VIEWS (SECURITY INVOKER)
-- ============================================================================
-- Ensure views run with permissions of the invoker, not the creator (owner)

ALTER VIEW public.monthly_financial_summary SET (security_invoker = true);
ALTER VIEW public.invoice_details SET (security_invoker = true);


-- ============================================================================
-- 4. ENABLE RLS AND POLICIES
-- ============================================================================

-- Helper function to get current owner_id from auth.uid()
CREATE OR REPLACE FUNCTION public.get_current_owner_id()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions, temp
AS $$
BEGIN
    -- Assumes users table links auth_id to owner_id
    RETURN (SELECT owner_id FROM public.users WHERE auth_id = auth.uid()::text LIMIT 1);
END;
$$;

-- Table: conversations
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own conversations" ON public.conversations;
CREATE POLICY "Users can view their own conversations"
ON public.conversations
FOR SELECT
USING (
    owner_id = get_current_owner_id()
);

DROP POLICY IF EXISTS "Users can insert their own conversations" ON public.conversations;
CREATE POLICY "Users can insert their own conversations"
ON public.conversations
FOR INSERT
WITH CHECK (
    owner_id = get_current_owner_id()
);

DROP POLICY IF EXISTS "Users can update their own conversations" ON public.conversations;
CREATE POLICY "Users can update their own conversations"
ON public.conversations
FOR UPDATE
USING (
    owner_id = get_current_owner_id()
);

-- Table: conversation_state_history
ALTER TABLE public.conversation_state_history ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view history of their conversations" ON public.conversation_state_history;
CREATE POLICY "Users can view history of their conversations"
ON public.conversation_state_history
FOR SELECT
USING (
    conv_id IN (
        SELECT conv_id FROM public.conversations 
        WHERE owner_id = get_current_owner_id()
    )
);

-- Table: person
-- Note: person table currently lacks owner_id, so we can't restrict by tenant effectively yet.
-- Enabling RLS as requested, but allowing authenticated users to access for now to prevent breakage while securing against anon.
ALTER TABLE public.person ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Authenticated users can view person" ON public.person;
CREATE POLICY "Authenticated users can view person"
ON public.person
FOR ALL
USING (
    auth.role() = 'authenticated'
);
#####

# migrations/006_unique_message_sid.sql
#####
-- ============================================================================
-- Unique Constraint on Message SID (Idempotency)
-- ============================================================================

CREATE UNIQUE INDEX IF NOT EXISTS idx_messages_metadata_message_sid 
ON messages ((metadata->>'message_sid'));

COMMENT ON INDEX idx_messages_metadata_message_sid IS 'Unique index on message_sid in metadata to prevent duplicates';
#####

# migrations/008_setup_vector_store.sql
#####
-- Enable the pgvector extension to work with embedding vectors
create extension if not exists vector;

-- Create a table to store your documents
-- Table: message_embeddings
-- Columns:
--   id: UUID primary key
--   content: Text content of the message/document
--   metadata: JSONB for additional info (owner_id, session_id, role, timestamp, etc.)
--   embedding: Vector(1536) compatible with OpenAI text-embedding-3-small
create table if not exists message_embeddings (
  id uuid primary key default gen_random_uuid(),
  content text,
  metadata jsonb,
  embedding vector(1536)
);

-- Create a function to search for documents
-- Function: match_message_embeddings
-- Args:
--   query_embedding: The vector to search for
--   match_threshold: Minimum similarity score (0-1) - default 0.5
--   match_count: Max number of results - default 10
--   filter: JSONB filter for metadata - default '{}'
create or replace function match_message_embeddings (
  query_embedding vector(1536),
  match_threshold float default 0.5,
  match_count int default 10,
  filter jsonb default '{}'
)
returns table (
  id uuid,
  content text,
  metadata jsonb,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    message_embeddings.id,
    message_embeddings.content,
    message_embeddings.metadata,
    1 - (message_embeddings.embedding <=> query_embedding) as similarity
  from message_embeddings
  where 1 - (message_embeddings.embedding <=> query_embedding) > match_threshold
  and message_embeddings.metadata @> filter
  order by message_embeddings.embedding <=> query_embedding
  limit match_count;
end;
$$;

-- Create an index for faster queries (IVFFlat)
-- Note: Create this only after having some data (e.g. > 2000 rows) for better centroid calculation.
-- create index on message_embeddings using ivfflat (embedding vector_cosine_ops)
-- with (lists = 100);#####

# migrations/004_feature_finance.sql
#####
-- ==============================================
-- Migração de Tabelas para Supabase
-- ==============================================
-- Execute este SQL no SQL Editor do Supabase
-- ou via Supabase CLI

-- Habilitar extensões úteis (opcional)
-- CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ==============================================
-- Tabela: revenue
-- ==============================================
CREATE TABLE IF NOT EXISTS revenue (
    id BIGSERIAL PRIMARY KEY,
    description TEXT NOT NULL,
    net_amount NUMERIC(12, 2) NOT NULL,
    gross_amount NUMERIC(12, 2) NOT NULL,
    tax_rate NUMERIC(5, 4) NOT NULL,
    date TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_revenue_date ON revenue(date);
CREATE INDEX IF NOT EXISTS idx_revenue_created_at ON revenue(created_at);

-- Trigger para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_revenue_updated_at
    BEFORE UPDATE ON revenue
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ==============================================
-- Tabela: expense
-- ==============================================
CREATE TABLE IF NOT EXISTS expense (
    id BIGSERIAL PRIMARY KEY,
    description TEXT NOT NULL,
    net_amount NUMERIC(12, 2) NOT NULL,
    gross_amount NUMERIC(12, 2) NOT NULL,
    tax_rate NUMERIC(5, 4) NOT NULL,
    date TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_expense_date ON expense(date);
CREATE INDEX IF NOT EXISTS idx_expense_created_at ON expense(created_at);

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_expense_updated_at
    BEFORE UPDATE ON expense
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ==============================================
-- Tabela: customer
-- ==============================================
CREATE TABLE IF NOT EXISTS customer (
    id BIGSERIAL PRIMARY KEY,
    company_name TEXT,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    phone TEXT NOT NULL,
    address TEXT NOT NULL,
    city TEXT NOT NULL,
    zip TEXT NOT NULL,
    country TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_customer_name ON customer(last_name, first_name);
CREATE INDEX IF NOT EXISTS idx_customer_phone ON customer(phone);
CREATE INDEX IF NOT EXISTS idx_customer_company ON customer(company_name);

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_customer_updated_at
    BEFORE UPDATE ON customer
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ==============================================
-- Tabela: invoice
-- ==============================================
CREATE TABLE IF NOT EXISTS invoice (
    id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT REFERENCES customer(id) ON DELETE SET NULL,
    invoice_number TEXT NOT NULL UNIQUE,
    description TEXT NOT NULL,
    amount NUMERIC(12, 2) NOT NULL,
    tax_rate NUMERIC(5, 4) NOT NULL,
    date TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_invoice_customer_id ON invoice(customer_id);
CREATE INDEX IF NOT EXISTS idx_invoice_number ON invoice(invoice_number);
CREATE INDEX IF NOT EXISTS idx_invoice_date ON invoice(date);

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_invoice_updated_at
    BEFORE UPDATE ON invoice
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();


-- ==============================================
-- Políticas RLS (Row Level Security) - Opcional
-- ==============================================
-- Descomente e ajuste conforme suas necessidades de segurança

-- Habilitar RLS
-- ALTER TABLE revenue ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE expense ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE customer ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE invoice ENABLE ROW LEVEL SECURITY;

-- Exemplo: Política que permite acesso apenas a dados do próprio usuário
-- Você precisará adicionar uma coluna user_id nas tabelas

-- CREATE POLICY "Users can view their own revenue"
--     ON revenue FOR SELECT
--     USING (auth.uid() = user_id);

-- CREATE POLICY "Users can insert their own revenue"
--     ON revenue FOR INSERT
--     WITH CHECK (auth.uid() = user_id);

-- CREATE POLICY "Users can update their own revenue"
--     ON revenue FOR UPDATE
--     USING (auth.uid() = user_id);

-- CREATE POLICY "Users can delete their own revenue"
--     ON revenue FOR DELETE
--     USING (auth.uid() = user_id);

-- Repita para as outras tabelas...


-- ==============================================
-- Dados de Exemplo (Seed Data) - Opcional
-- ==============================================
-- Descomente para inserir dados de teste

-- INSERT INTO customer (company_name, first_name, last_name, phone, address, city, zip, country) VALUES
-- ('Tech Corp', 'John', 'Doe', '+1234567890', '123 Main St', 'New York', '10001', 'USA'),
-- ('Design Ltd', 'Jane', 'Smith', '+0987654321', '456 Oak Ave', 'Los Angeles', '90001', 'USA'),
-- (NULL, 'Bob', 'Johnson', '+1122334455', '789 Pine Rd', 'Chicago', '60601', 'USA');

-- INSERT INTO revenue (description, net_amount, gross_amount, tax_rate, date) VALUES
-- ('Consulting services', 1000.00, 1190.00, 0.19, '2024-01-15 10:00:00'),
-- ('Software license', 500.00, 595.00, 0.19, '2024-02-20 14:30:00'),
-- ('Training workshop', 1500.00, 1785.00, 0.19, '2024-03-10 09:00:00');

-- INSERT INTO expense (description, net_amount, gross_amount, tax_rate, date) VALUES
-- ('Office supplies', 100.00, 119.00, 0.19, '2024-01-10 08:00:00'),
-- ('Software subscription', 50.00, 59.50, 0.19, '2024-02-05 12:00:00'),
-- ('Marketing campaign', 300.00, 357.00, 0.19, '2024-03-15 16:00:00');

-- INSERT INTO invoice (customer_id, invoice_number, description, amount, tax_rate, date) VALUES
-- (1, 'INV-1001', 'Website development', 1500.00, 0.19, '2024-01-20 10:00:00'),
-- (2, 'INV-1002', 'Project completion', 2380.00, 0.19, '2024-02-15 11:00:00'),
-- (3, 'INV-1003', 'Software license', 595.00, 0.19, '2024-03-10 15:00:00');


-- ==============================================
-- Views úteis (Opcional)
-- ==============================================

-- View para resumo financeiro mensal
CREATE OR REPLACE VIEW monthly_financial_summary AS
SELECT 
    DATE_TRUNC('month', date) AS month,
    'revenue' AS type,
    SUM(gross_amount) AS total_amount,
    COUNT(*) AS transaction_count
FROM revenue
GROUP BY DATE_TRUNC('month', date)
UNION ALL
SELECT 
    DATE_TRUNC('month', date) AS month,
    'expense' AS type,
    SUM(gross_amount) AS total_amount,
    COUNT(*) AS transaction_count
FROM expense
GROUP BY DATE_TRUNC('month', date)
ORDER BY month DESC, type;

-- View para invoices com informações do cliente
CREATE OR REPLACE VIEW invoice_details AS
SELECT 
    i.id,
    i.invoice_number,
    i.description,
    i.amount,
    i.tax_rate,
    i.date,
    c.company_name,
    c.first_name,
    c.last_name,
    c.phone,
    c.city,
    c.country
FROM invoice i
LEFT JOIN customer c ON i.customer_id = c.id;


-- ==============================================
-- Comentários nas tabelas (Documentação)
-- ==============================================

COMMENT ON TABLE revenue IS 'Tabela de receitas da empresa';
COMMENT ON TABLE expense IS 'Tabela de despesas da empresa';
COMMENT ON TABLE customer IS 'Tabela de clientes';
COMMENT ON TABLE invoice IS 'Tabela de faturas emitidas';

COMMENT ON COLUMN revenue.net_amount IS 'Valor líquido (antes dos impostos)';
COMMENT ON COLUMN revenue.gross_amount IS 'Valor bruto (com impostos)';
COMMENT ON COLUMN revenue.tax_rate IS 'Taxa de imposto aplicada (ex: 0.19 para 19%)';

COMMENT ON COLUMN expense.net_amount IS 'Valor líquido da despesa (antes dos impostos)';
COMMENT ON COLUMN expense.gross_amount IS 'Valor bruto da despesa (com impostos)';
COMMENT ON COLUMN expense.tax_rate IS 'Taxa de imposto aplicada (ex: 0.19 para 19%)';
#####

# migrations/015_fix_remaining_search_paths.sql
#####
-- Migration: Fix mutable search path for remaining functions
-- Created at: 2026-02-02
-- Description: Fixes search_path for set_history_id_on_insert and dynamically fixes get_ulid_from_id/get_id_from_ulid if they exist.

-- 1. Fix known function
ALTER FUNCTION public.set_history_id_on_insert() SET search_path = public, extensions, temp;

-- 2. Dynamically fix potentially existing legacy functions (get_ulid_from_id, get_id_from_ulid)
-- We use dynamic SQL to avoid migration errors if these functions do not exist or have unknown signatures.
DO $$
DECLARE
    func_record RECORD;
BEGIN
    -- Fix get_ulid_from_id (all overloads)
    FOR func_record IN 
        SELECT oid::regprocedure as signature 
        FROM pg_proc 
        WHERE proname = 'get_ulid_from_id' AND pronamespace = 'public'::regnamespace
    LOOP
        RAISE NOTICE 'Securing function: %', func_record.signature;
        EXECUTE format('ALTER FUNCTION %s SET search_path = public, extensions, temp', func_record.signature);
    END LOOP;

    -- Fix get_id_from_ulid (all overloads)
    FOR func_record IN 
        SELECT oid::regprocedure as signature 
        FROM pg_proc 
        WHERE proname = 'get_id_from_ulid' AND pronamespace = 'public'::regnamespace
    LOOP
        RAISE NOTICE 'Securing function: %', func_record.signature;
        EXECUTE format('ALTER FUNCTION %s SET search_path = public, extensions, temp', func_record.signature);
    END LOOP;
END $$;
#####

# migrations/000_drop_schema.sql
#####
-- ============================================================================
-- Owner Project - Database Cleanup Script
-- Removes all database objects in correct dependency order
-- ============================================================================

-- Disable foreign key checks temporarily
SET session_replication_role = 'replica';

-- ============================================================================
-- 1. DROP TABLES (in reverse dependency order)
-- ============================================================================
-- Drop child tables first
DROP TABLE IF EXISTS reminder CASCADE;
DROP TABLE IF EXISTS interaction CASCADE;
DROP TABLE IF EXISTS person CASCADE;
DROP TABLE IF EXISTS subscriptions CASCADE;
DROP TABLE IF EXISTS plan_features CASCADE;
DROP TABLE IF EXISTS plans CASCADE;
DROP TABLE IF EXISTS conversation_state_history CASCADE;
DROP TABLE IF EXISTS ai_results CASCADE;
DROP TABLE IF EXISTS messages CASCADE;
DROP TABLE IF EXISTS conversations CASCADE;
DROP TABLE IF EXISTS twilio_accounts CASCADE;
DROP TABLE IF EXISTS features CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS owners CASCADE;

DROP TABLE IF EXISTS message_embeddings CASCADE;

-- ============================================================================
-- 2. DROP TABLEs Features
-- ============================================================================
-- relationships
DROP TABLE IF EXISTS person CASCADE;
DROP TABLE IF EXISTS interaction CASCADE;
DROP TABLE IF EXISTS reminder CASCADE;

-- Finance
DROP TABLE IF EXISTS revenue CASCADE;
DROP TABLE IF EXISTS expense CASCADE;
DROP TABLE IF EXISTS customer CASCADE;
DROP TABLE IF EXISTS invoice CASCADE;

-- ============================================================================
-- 2. DROP FUNCTIONS
-- ============================================================================
DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;
DROP FUNCTION IF EXISTS generate_ulid() CASCADE;
DROP FUNCTION IF EXISTS is_valid_ulid(TEXT) CASCADE;
DROP FUNCTION IF EXISTS ulid_to_timestamp(TEXT) CASCADE;
DROP FUNCTION IF EXISTS set_ulid_on_insert() CASCADE;
DROP FUNCTION IF EXISTS set_ulid_on_insert_v2() CASCADE;
DROP FUNCTION IF EXISTS set_owners_id_on_insert() CASCADE;
DROP FUNCTION IF EXISTS set_users_id_on_insert() CASCADE;
DROP FUNCTION IF EXISTS set_conversations_id_on_insert() CASCADE;
DROP FUNCTION IF EXISTS set_messages_id_on_insert() CASCADE;
DROP FUNCTION IF EXISTS set_ai_results_id_on_insert() CASCADE;

-- ============================================================================
-- 3. DROP EXTENSIONS (optional - only if needed)
-- ============================================================================
-- Uncomment if you want to remove the extension completely
-- DROP EXTENSION IF EXISTS "uuid-ossp" CASCADE;

-- Re-enable foreign key checks
SET session_replication_role = 'origin';

-- ============================================================================
-- Completion Message
-- ============================================================================
DO $$
BEGIN
    RAISE NOTICE '==============================================';
    RAISE NOTICE 'Database cleanup completed successfully!';
    RAISE NOTICE 'All tables and functions removed.';
    RAISE NOTICE '==============================================';
END $$;
#####

# migrations/016_optimize_person_rls.sql
#####
-- Migration: Optimize RLS for Person Table
-- Created at: 2026-02-02
-- Description: Improves performance by avoiding per-row evaluation of auth.role()
-- Reference: https://supabase.com/docs/guides/database/postgres/row-level-security#performance

DROP POLICY IF EXISTS "Authenticated users can view person" ON public.person;

CREATE POLICY "Authenticated users can view person"
ON public.person
FOR ALL
USING (
    (SELECT auth.role()) = 'authenticated'
);
#####

# migrations/001_initial_schema.sql
#####
-- ============================================================================
-- Owner Project - Database Schema (Consolidated with ULID)
-- Multi-tenant conversation management system with Twilio integration
-- ============================================================================
-- This schema uses ULID (Universally Unique Lexicographically Sortable ID)
-- for primary keys instead of BIGSERIAL for better security and scalability.
--
-- ULID Format: 01ARZ3NDEKTSV4RRFFQ69G5FAV (26 characters)
-- Encoding: Crockford's Base32
-- Structure: TTTTTTTTTTRRRRRRRRRRRRRRRR
--            |________| |______________|
--             Timestamp   Randomness
--            (10 chars)    (16 chars)
-- ============================================================================

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================================
-- ULID GENERATION FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION generate_ulid() RETURNS TEXT AS $$
DECLARE
    -- Crockford's Base32 alphabet (excludes I, L, O, U to avoid confusion)
    encoding   TEXT := '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
    timestamp  BIGINT;
    output     TEXT := '';
    unix_time  BIGINT;
    random_part BIGINT;
BEGIN
    -- Get current timestamp in milliseconds
    unix_time := (EXTRACT(EPOCH FROM CLOCK_TIMESTAMP()) * 1000)::BIGINT;
    timestamp := unix_time;
    
    -- Encode timestamp (10 characters)
    FOR i IN 1..10 LOOP
        -- Explicitly cast position to INTEGER to fix 'function substring does not exist' error
        output := output || SUBSTRING(encoding FROM ((timestamp % 32) + 1)::INTEGER FOR 1);
        timestamp := timestamp / 32;
    END LOOP;
    
    -- Add random part (16 characters)
    FOR i IN 1..16 LOOP
        random_part := (RANDOM() * 31)::INTEGER;
        output := output || SUBSTRING(encoding FROM (random_part + 1)::INTEGER FOR 1);
    END LOOP;
    
    RETURN output;
END;
$$ LANGUAGE plpgsql VOLATILE;

COMMENT ON FUNCTION generate_ulid() IS 'Generate ULID (Universally Unique Lexicographically Sortable Identifier) - Fixed Type Casting';

-- ============================================================================
-- ULID VALIDATION FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION is_valid_ulid(ulid TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    encoding TEXT := '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
    char TEXT;
BEGIN
    -- Check length
    IF LENGTH(ulid) != 26 THEN
        RETURN FALSE;
    END IF;
    
    -- Check if all characters are in the encoding alphabet
    FOR i IN 1..26 LOOP
        char := SUBSTRING(ulid FROM i FOR 1);
        IF POSITION(char IN encoding) = 0 THEN
            RETURN FALSE;
        END IF;
    END LOOP;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION is_valid_ulid(TEXT) IS 'Validate ULID format (26 chars, Crockford Base32)';

-- ============================================================================
-- ULID TO TIMESTAMP FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION ulid_to_timestamp(ulid TEXT)
RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
    encoding TEXT := '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
    timestamp_part TEXT;
    unix_ms BIGINT := 0;
    char_val INTEGER;
BEGIN
    IF NOT is_valid_ulid(ulid) THEN
        RAISE EXCEPTION 'Invalid ULID format: %', ulid;
    END IF;
    
    -- Extract timestamp part (first 10 characters)
    timestamp_part := SUBSTRING(ulid FROM 1 FOR 10);
    
    -- Decode Base32 timestamp
    FOR i IN REVERSE 10..1 LOOP
        char_val := POSITION(SUBSTRING(timestamp_part FROM i FOR 1) IN encoding) - 1;
        unix_ms := unix_ms + (char_val * (32 ^ (10 - i)));
    END LOOP;
    
    -- Convert milliseconds to timestamp
    RETURN TO_TIMESTAMP(unix_ms / 1000.0);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION ulid_to_timestamp(TEXT) IS 'Extract timestamp from ULID';

-- ============================================================================
-- 1. OWNERS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS owners (
    owner_id   TEXT PRIMARY KEY DEFAULT generate_ulid(),
    name       TEXT NOT NULL,
    email      TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    active     BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_owners_email ON owners(email);
CREATE INDEX idx_owners_active ON owners(active);

COMMENT ON TABLE owners IS 'Tenants/organizations in the system';
COMMENT ON COLUMN owners.owner_id IS 'Unique ULID identifier for the owner';
COMMENT ON COLUMN owners.name IS 'Owner/organization name';
COMMENT ON COLUMN owners.email IS 'Contact email for the owner';
COMMENT ON COLUMN owners.active IS 'Whether the owner account is active';

-- ============================================================================
-- 2. USERS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS users (
    user_id      TEXT PRIMARY KEY DEFAULT generate_ulid(),
    owner_id     TEXT NOT NULL REFERENCES owners(owner_id) ON DELETE CASCADE,
    profile_name TEXT,
    first_name   TEXT,
    last_name    TEXT,
    role         TEXT CHECK (role IN ('admin', 'agent', 'user')) DEFAULT 'user',
    phone        TEXT,
    active       BOOLEAN DEFAULT TRUE,
    created_at   TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_users_owner_id ON users(owner_id);
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_role ON users(owner_id, role);
CREATE INDEX idx_users_active ON users(owner_id, active);
CREATE INDEX idx_users_owner_phone ON users(owner_id, phone) WHERE phone IS NOT NULL;

COMMENT ON TABLE users IS 'Staff members associated with owners';
COMMENT ON COLUMN users.user_id IS 'Unique ULID identifier for the user';
COMMENT ON COLUMN users.owner_id IS 'ULID reference to parent owner';
COMMENT ON COLUMN users.role IS 'User role: admin, agent, or user';

-- ============================================================================
-- 3. FEATURES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS features (
    feature_id  BIGSERIAL PRIMARY KEY,
    owner_id    TEXT NOT NULL REFERENCES owners(owner_id) ON DELETE CASCADE,
    name        TEXT NOT NULL,
    description TEXT,
    enabled     BOOLEAN DEFAULT FALSE,
    config_json JSONB DEFAULT '{}'::jsonb,
    created_at  TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at  TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_features_owner_id ON features(owner_id);
CREATE INDEX idx_features_enabled ON features(owner_id, enabled);
CREATE UNIQUE INDEX idx_features_owner_name ON features(owner_id, name);

-- JSONB Indexes for features.config_json
CREATE INDEX idx_features_config_gin ON features USING gin(config_json);
CREATE INDEX idx_features_config_enabled ON features((config_json->>'enabled')) 
WHERE config_json->>'enabled' IS NOT NULL;

COMMENT ON TABLE features IS 'Features/functions that can be enabled per owner';
COMMENT ON COLUMN features.owner_id IS 'ULID reference to parent owner';
COMMENT ON COLUMN features.config_json IS 'Feature-specific configuration in JSON format';
COMMENT ON INDEX idx_features_config_gin IS 'GIN index for efficient JSONB queries (containment, key existence)';
COMMENT ON INDEX idx_features_config_enabled IS 'Partial index for enabled flag in config_json';

-- ============================================================================
-- 4. PLANS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS plans (
    plan_id     TEXT PRIMARY KEY DEFAULT generate_ulid(),
    name        TEXT UNIQUE NOT NULL,
    display_name TEXT NOT NULL,
    description TEXT,
    price_cents INTEGER NOT NULL DEFAULT 0,
    billing_period TEXT CHECK (billing_period IN ('monthly', 'yearly', 'lifetime')) DEFAULT 'monthly',
    is_public   BOOLEAN DEFAULT TRUE,
    max_users   INTEGER,
    max_projects INTEGER,
    config_json JSONB DEFAULT '{}'::jsonb,
    created_at  TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at  TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    active      BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_plans_active ON plans(active);
CREATE INDEX idx_plans_public ON plans(is_public, active);

-- ============================================================================
-- 5. PLAN_FEATURES TABLE (Many-to-Many)
-- ============================================================================
CREATE TABLE IF NOT EXISTS plan_features (
    plan_feature_id BIGSERIAL PRIMARY KEY,
    plan_id         TEXT NOT NULL REFERENCES plans(plan_id) ON DELETE CASCADE,
    feature_name    TEXT NOT NULL,
    feature_value   JSONB DEFAULT '{}'::jsonb,
    created_at      TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_plan_features_plan_name ON plan_features(plan_id, feature_name);
CREATE INDEX idx_plan_features_plan_id ON plan_features(plan_id);

-- ============================================================================
-- 6. SUBSCRIPTIONS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS subscriptions (
    subscription_id TEXT PRIMARY KEY DEFAULT generate_ulid(),
    owner_id        TEXT NOT NULL REFERENCES owners(owner_id) ON DELETE CASCADE,
    plan_id         TEXT NOT NULL REFERENCES plans(plan_id),
    status          TEXT CHECK (status IN ('active', 'canceled', 'expired', 'trial')) DEFAULT 'trial',
    started_at      TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at      TIMESTAMP WITH TIME ZONE,
    canceled_at     TIMESTAMP WITH TIME ZONE,
    trial_ends_at   TIMESTAMP WITH TIME ZONE,
    config_json     JSONB DEFAULT '{}'::jsonb,
    created_at      TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at      TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_subscriptions_owner_id ON subscriptions(owner_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(owner_id, status);
CREATE INDEX idx_subscriptions_expires_at ON subscriptions(expires_at) WHERE expires_at IS NOT NULL;

-- Constraint: apenas uma subscription ativa por owner
CREATE UNIQUE INDEX idx_subscriptions_owner_active 
ON subscriptions(owner_id) 
WHERE status = 'active';

-- ============================================================================
-- 7. TWILIO ACCOUNTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS twilio_accounts (
    tw_account_id BIGSERIAL PRIMARY KEY,
    owner_id      TEXT NOT NULL REFERENCES owners(owner_id) ON DELETE CASCADE,
    account_sid   TEXT NOT NULL,
    auth_token    TEXT NOT NULL,
    phone_numbers JSONB DEFAULT '[]'::jsonb,
    created_at    TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_twilio_accounts_owner_id ON twilio_accounts(owner_id);
CREATE INDEX idx_twilio_sid ON twilio_accounts(account_sid);

-- JSONB Index for twilio_accounts.phone_numbers
CREATE INDEX idx_twilio_phone_numbers_gin ON twilio_accounts USING gin(phone_numbers);

COMMENT ON TABLE twilio_accounts IS 'Twilio credentials for each owner';
COMMENT ON COLUMN twilio_accounts.owner_id IS 'ULID reference to parent owner';
COMMENT ON COLUMN twilio_accounts.phone_numbers IS 'Array of Twilio phone numbers';
COMMENT ON INDEX idx_twilio_phone_numbers_gin IS 'GIN index for searching phone numbers in JSONB array';

-- ============================================================================
-- 8. CONVERSATIONS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS conversations (
    conv_id      TEXT PRIMARY KEY DEFAULT generate_ulid(),
    owner_id     TEXT NOT NULL REFERENCES owners(owner_id) ON DELETE CASCADE,
    user_id      TEXT REFERENCES users(user_id) ON DELETE SET NULL,
    from_number  TEXT NOT NULL,
    to_number    TEXT NOT NULL,
    status       TEXT CHECK (status IN (
        'pending', 'progress', 'agent_closed', 'support_closed',
        'user_closed', 'expired', 'failed', 'idle_timeout'
    )) DEFAULT 'pending',
    started_at   TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ended_at     TIMESTAMP WITH TIME ZONE,
    updated_at   TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at   TIMESTAMP WITH TIME ZONE,
    channel      TEXT DEFAULT 'whatsapp',
    phone_number TEXT,
    context      JSONB DEFAULT '{}'::jsonb,
    metadata     JSONB DEFAULT '{}'::jsonb
);

-- Session key column (computed automatically)
ALTER TABLE conversations 
ADD COLUMN session_key TEXT GENERATED ALWAYS AS (
    CASE 
        WHEN from_number < to_number 
        THEN from_number || '::' || to_number
        ELSE to_number || '::' || from_number
    END
) STORED;

COMMENT ON COLUMN conversations.conv_id IS 'Unique ULID identifier for the conversation';
COMMENT ON COLUMN conversations.owner_id IS 'ULID reference to parent owner';
COMMENT ON COLUMN conversations.user_id IS 'ULID reference to assigned user';
COMMENT ON COLUMN conversations.session_key IS 
'Bidirectional conversation identifier: always sorted alphabetically regardless of message direction';

-- Standard indexes
CREATE UNIQUE INDEX idx_conversations_session_key_active 
ON conversations(owner_id, session_key)
WHERE status IN ('pending', 'progress');

CREATE INDEX idx_conversations_owner_id ON conversations(owner_id);
CREATE INDEX idx_conversations_user_id ON conversations(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_conversations_status ON conversations(status);
CREATE INDEX idx_conversations_from ON conversations(from_number);
CREATE INDEX idx_conversations_active ON conversations(owner_id, from_number, to_number, status);
CREATE INDEX idx_conversations_expires ON conversations(expires_at) WHERE status IN ('pending', 'progress');
CREATE INDEX idx_conversations_updated ON conversations(updated_at) WHERE status IN ('pending', 'progress');
CREATE INDEX idx_conversations_owner_session ON conversations(owner_id, session_key, status);

-- JSONB Indexes for conversations.context
CREATE INDEX idx_conversations_context_gin ON conversations USING gin(context);
CREATE INDEX idx_conversations_context_status ON conversations((context->>'customer_id'), status)
WHERE context->>'customer_id' IS NOT NULL;

-- JSONB Indexes for conversations.metadata
CREATE INDEX idx_conversations_metadata_gin ON conversations USING gin(metadata);
CREATE INDEX idx_conversations_metadata_priority ON conversations((metadata->>'priority'))
WHERE metadata->>'priority' = 'high';

COMMENT ON TABLE conversations IS 'Conversations between users and the system';
COMMENT ON COLUMN conversations.status IS 'Current conversation status';
COMMENT ON COLUMN conversations.context IS 'Conversation context data';
COMMENT ON COLUMN conversations.metadata IS 'Additional metadata';
COMMENT ON INDEX idx_conversations_context_gin IS 'GIN index for efficient context JSONB queries';
COMMENT ON INDEX idx_conversations_metadata_gin IS 'GIN index for efficient metadata JSONB queries';

-- ============================================================================
-- 9. MESSAGES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS messages (
    msg_id        TEXT PRIMARY KEY DEFAULT generate_ulid(),
    conv_id       TEXT NOT NULL REFERENCES conversations(conv_id) ON DELETE CASCADE,
    owner_id      TEXT NOT NULL REFERENCES owners(owner_id) ON DELETE CASCADE,
    from_number   TEXT NOT NULL,
    to_number     TEXT NOT NULL,
    body          TEXT NOT NULL,
    direction     TEXT CHECK (direction IN ('inbound', 'outbound')) DEFAULT 'inbound',
    timestamp     TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_by_ia    BOOLEAN DEFAULT FALSE,
    message_owner TEXT CHECK (message_owner IN ('user', 'agent', 'system', 'tool', 'support')) DEFAULT 'user',
    message_type  TEXT CHECK (message_type IN ('text', 'image', 'audio', 'video', 'document')) DEFAULT 'text',
    content       TEXT,
    metadata      JSONB DEFAULT '{}'::jsonb
);

CREATE INDEX idx_messages_conv_id ON messages(conv_id);
CREATE INDEX idx_messages_owner_id ON messages(owner_id);
CREATE INDEX idx_messages_conv_ts ON messages(conv_id, timestamp);
CREATE INDEX idx_messages_direction ON messages(direction);
CREATE INDEX idx_messages_owner ON messages(message_owner);

-- JSONB Index for messages.metadata
CREATE INDEX idx_messages_metadata_gin ON messages USING gin(metadata);
CREATE INDEX idx_messages_metadata_delivery_status ON messages((metadata->>'delivery_status'))
WHERE metadata->>'delivery_status' IS NOT NULL;

COMMENT ON TABLE messages IS 'Messages within conversations';
COMMENT ON COLUMN messages.msg_id IS 'Unique ULID identifier for the message';
COMMENT ON COLUMN messages.conv_id IS 'ULID reference to parent conversation';
COMMENT ON COLUMN messages.owner_id IS 'ULID reference to parent owner (denormalized for RLS/triggers)';
COMMENT ON COLUMN messages.direction IS 'Message direction: inbound or outbound';
COMMENT ON COLUMN messages.message_owner IS 'Who sent the message';
COMMENT ON COLUMN messages.message_type IS 'Type of message content';
COMMENT ON INDEX idx_messages_metadata_gin IS 'GIN index for efficient metadata JSONB queries';

-- ============================================================================
-- 10. AI RESULTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS ai_results (
    ai_result_id TEXT PRIMARY KEY DEFAULT generate_ulid(),
    msg_id       TEXT NOT NULL REFERENCES messages(msg_id) ON DELETE CASCADE,
    feature_id   BIGINT NOT NULL REFERENCES features(feature_id) ON DELETE CASCADE,
    result_json  JSONB NOT NULL,
    processed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_ai_results_msg_id ON ai_results(msg_id);
CREATE INDEX idx_ai_results_feature ON ai_results(feature_id);
CREATE INDEX idx_ai_results_processed ON ai_results(processed_at);

-- JSONB Indexes for ai_results.result_json
CREATE INDEX idx_ai_results_json_gin ON ai_results USING gin(result_json);
CREATE INDEX idx_ai_results_json_confidence ON ai_results(((result_json->'analysis'->>'confidence')::numeric))
WHERE result_json->'analysis'->>'confidence' IS NOT NULL;
CREATE INDEX idx_ai_results_json_category ON ai_results((result_json->>'category'))
WHERE result_json->>'category' IS NOT NULL;

COMMENT ON TABLE ai_results IS 'AI processing results for messages';
COMMENT ON COLUMN ai_results.ai_result_id IS 'Unique ULID identifier for the AI result';
COMMENT ON COLUMN ai_results.msg_id IS 'ULID reference to parent message';
COMMENT ON COLUMN ai_results.result_json IS 'AI processing output in JSON format';
COMMENT ON INDEX idx_ai_results_json_gin IS 'GIN index for efficient result_json queries';
COMMENT ON INDEX idx_ai_results_json_confidence IS 'Expression index for AI confidence scores';

-- ============================================================================
-- FUNCTIONS AND TRIGGERS
-- ============================================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := timezone('UTC', now());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for conversations
DROP TRIGGER IF EXISTS update_conversations_updated_at ON conversations;
CREATE TRIGGER update_conversations_updated_at
    BEFORE UPDATE ON conversations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Trigger for features
DROP TRIGGER IF EXISTS update_features_updated_at ON features;
CREATE TRIGGER update_features_updated_at
    BEFORE UPDATE ON features
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_plans_updated_at BEFORE UPDATE ON plans
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();    

-- ============================================================================
-- ULID AUTO-GENERATION TRIGGERS
-- ============================================================================

-- Specific trigger functions for each table to avoid field access errors
-- Each function only accesses fields that exist in its specific table

CREATE OR REPLACE FUNCTION set_owners_id_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.owner_id IS NULL THEN
        NEW.owner_id := generate_ulid();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION set_users_id_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.user_id IS NULL THEN
        NEW.user_id := generate_ulid();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION set_conversations_id_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.conv_id IS NULL THEN
        NEW.conv_id := generate_ulid();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION set_messages_id_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.msg_id IS NULL THEN
        NEW.msg_id := generate_ulid();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION set_ai_results_id_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.ai_result_id IS NULL THEN
        NEW.ai_result_id := generate_ulid();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers with specific functions
DROP TRIGGER IF EXISTS trigger_owners_ulid ON owners;
CREATE TRIGGER trigger_owners_ulid
    BEFORE INSERT ON owners
    FOR EACH ROW
    EXECUTE FUNCTION set_owners_id_on_insert();

DROP TRIGGER IF EXISTS trigger_users_ulid ON users;
CREATE TRIGGER trigger_users_ulid
    BEFORE INSERT ON users
    FOR EACH ROW
    EXECUTE FUNCTION set_users_id_on_insert();

DROP TRIGGER IF EXISTS trigger_conversations_ulid ON conversations;
CREATE TRIGGER trigger_conversations_ulid
    BEFORE INSERT ON conversations
    FOR EACH ROW
    EXECUTE FUNCTION set_conversations_id_on_insert();

DROP TRIGGER IF EXISTS trigger_messages_ulid ON messages;
CREATE TRIGGER trigger_messages_ulid
    BEFORE INSERT ON messages
    FOR EACH ROW
    EXECUTE FUNCTION set_messages_id_on_insert();

DROP TRIGGER IF EXISTS trigger_ai_results_ulid ON ai_results;
CREATE TRIGGER trigger_ai_results_ulid
    BEFORE INSERT ON ai_results
    FOR EACH ROW
    EXECUTE FUNCTION set_ai_results_id_on_insert();

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) SETUP
-- ============================================================================

-- Enable RLS on all tables (commented out by default)
-- ALTER TABLE owners ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE users ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE features ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE twilio_accounts ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE ai_results ENABLE ROW LEVEL SECURITY;

-- Create policies (these are examples - adjust based on your auth setup)
CREATE POLICY "Enable read access for all users" ON owners
    FOR SELECT USING (true);

CREATE POLICY "Users can view own owner's users" ON users
    FOR SELECT USING (true);

CREATE POLICY "Features viewable by owner" ON features
    FOR SELECT USING (true);

CREATE POLICY "Conversations viewable by owner" ON conversations
    FOR SELECT USING (true);

CREATE POLICY "Messages viewable via conversation" ON messages
    FOR SELECT USING (true);

-- ============================================================================
-- GRANTS
-- ============================================================================

-- Grant usage on sequences
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO postgres, anon, authenticated, service_role;

-- Grant table permissions
GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres, service_role;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO anon;

-- ============================================================================
-- JSONB INDEXING GUIDE AND BEST PRACTICES
-- ============================================================================

/*
===================================================================================
JSONB INDEXING STRATEGIES IMPLEMENTED
===================================================================================

1. GIN INDEXES (Generalized Inverted Index)
   - Best for: Containment queries (@>, <@), key existence (?), array operations
   - Usage: WHERE jsonb_column @> '{"key": "value"}'
   - Applied to: ALL JSONB columns for general flexibility

2. EXPRESSION INDEXES
   - Best for: Specific key access, ordering, filtering
   - Usage: WHERE (jsonb_column->>'key') = 'value'
   - Applied to: Frequently accessed keys (examples provided)

3. PARTIAL INDEXES
   - Best for: Filtering common conditions
   - Usage: Indexes only relevant subset of data
   - Applied to: High priority or specific status fields

===================================================================================
QUERY EXAMPLES FOR INDEXED FIELDS
===================================================================================

-- Features config_json queries (uses idx_features_config_gin)
SELECT * FROM features 
WHERE config_json @> '{"api_enabled": true}';

SELECT * FROM features 
WHERE config_json ? 'webhook_url';

-- Features enabled flag (uses idx_features_config_enabled)
SELECT * FROM features 
WHERE config_json->>'enabled' = 'true';

-- Twilio phone numbers (uses idx_twilio_phone_numbers_gin)
SELECT * FROM twilio_accounts 
WHERE phone_numbers @> '["+1234567890"]';

-- Conversations context queries (uses idx_conversations_context_gin)
SELECT * FROM conversations 
WHERE context @> '{"language": "pt-BR"}';

-- Conversations context by customer_id (uses idx_conversations_context_status)
SELECT * FROM conversations 
WHERE context->>'customer_id' = '12345' 
AND status = 'progress';

-- Messages metadata queries (uses idx_messages_metadata_gin)
SELECT * FROM messages 
WHERE metadata @> '{"read": true}';

-- AI results queries (uses idx_ai_results_json_gin)
SELECT * FROM ai_results 
WHERE result_json @> '{"status": "success"}';

===================================================================================
ULID USAGE EXAMPLES
===================================================================================

-- Generate a new ULID
SELECT generate_ulid();

-- Validate ULID format
SELECT is_valid_ulid('01ARZ3NDEKTSV4RRFFQ69G5FAV'); -- Returns TRUE
SELECT is_valid_ulid('invalid'); -- Returns FALSE

-- Extract timestamp from ULID
SELECT ulid_to_timestamp('01ARZ3NDEKTSV4RRFFQ69G5FAV');

-- Test insert with auto-generated ULID
INSERT INTO owners (name, email) VALUES ('Test Owner', 'test@example.com')
RETURNING owner_id;

===================================================================================
MAINTENANCE COMMANDS
===================================================================================

-- Check index usage statistics
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- Check index sizes
SELECT
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

-- Rebuild indexes if needed (after bulk updates)
REINDEX TABLE conversations;
REINDEX TABLE messages;
REINDEX TABLE ai_results;

-- Update table statistics for query planner
ANALYZE conversations;
ANALYZE messages;
ANALYZE ai_results;
ANALYZE features;

===================================================================================
*/

-- ============================================================================
-- COMPLETION MESSAGE
-- ============================================================================

DO $$
BEGIN
    RAISE NOTICE '==============================================';
    RAISE NOTICE 'Database schema created successfully!';
    RAISE NOTICE '==============================================';
    RAISE NOTICE 'Schema Features:';
    RAISE NOTICE '✓ ULID primary keys for security and scalability';
    RAISE NOTICE '✓ JSONB columns with optimized indexing';
    RAISE NOTICE '✓ Automatic timestamp tracking';
    RAISE NOTICE '✓ Row Level Security policies (disabled by default)';
    RAISE NOTICE '✓ Foreign key constraints with CASCADE';
    RAISE NOTICE '✓ Computed session_key for bidirectional conversations';
    RAISE NOTICE '==============================================';
END $$;
#####

# migrations/013_update_partial_indexes_status.sql
#####
-- Migration: Update partial indexes to include human_handoff status
-- Created at: 2026-02-02
-- Description: Updates partial indexes to include 'human_handoff' which is considered an active status in the application logic.
-- Previous definition only covered 'pending' and 'progress'.

-- 1. Recreate Unique Index for Active Sessions
DROP INDEX IF EXISTS idx_conversations_session_key_active;
CREATE UNIQUE INDEX idx_conversations_session_key_active 
ON conversations(owner_id, session_key)
WHERE status IN ('pending', 'progress', 'human_handoff');

-- 2. Recreate Index for Expiration Queries
DROP INDEX IF EXISTS idx_conversations_expires;
CREATE INDEX idx_conversations_expires 
ON conversations(expires_at) 
WHERE status IN ('pending', 'progress', 'human_handoff');

-- 3. Recreate Index for Updates/Ordering
DROP INDEX IF EXISTS idx_conversations_updated;
CREATE INDEX idx_conversations_updated 
ON conversations(updated_at) 
WHERE status IN ('pending', 'progress', 'human_handoff');
#####

# migrations/002_add_auth_id_to_users.sql
#####
ALTER TABLE users ADD COLUMN auth_id TEXT UNIQUE;
CREATE INDEX idx_users_auth_id ON users(auth_id);
COMMENT ON COLUMN users.auth_id IS 'External authentication ID (e.g. from Supabase Auth)';
#####

# migrations/002_add_correlation_id.sql
#####
-- ============================================================================
-- 1. ADD CORRELATION_ID TO MESSAGES
-- ============================================================================
ALTER TABLE messages 
ADD COLUMN IF NOT EXISTS correlation_id TEXT;

-- Index for fast lookup of interaction history
CREATE INDEX IF NOT EXISTS idx_messages_correlation_id ON messages(correlation_id);

COMMENT ON COLUMN messages.correlation_id IS 'Trace ID linking inbound trigger to outbound response';

-- ============================================================================
-- 2. ADD CORRELATION_ID TO AI_RESULTS
-- ============================================================================
ALTER TABLE ai_results 
ADD COLUMN IF NOT EXISTS correlation_id TEXT;

-- Index for joining with messages/analytics
CREATE INDEX IF NOT EXISTS idx_ai_results_correlation_id ON ai_results(correlation_id);

COMMENT ON COLUMN ai_results.correlation_id IS 'Trace ID linking AI processing to the specific interaction cycle';
#####

# migrations/003_add_version_column.sql
#####
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1 NOT NULL;
#####

# migrations/005_add_ai_result_type.sql
#####
-- ==============================================
-- Migration: Add result_type to ai_results
-- ==============================================

-- Add result_type column with check constraint and default value
ALTER TABLE ai_results
ADD COLUMN IF NOT EXISTS result_type TEXT 
CHECK (result_type IN ('tool', 'agent_log', 'agent_response')) 
DEFAULT 'agent_log';

-- Add comment for documentation
COMMENT ON COLUMN ai_results.result_type IS 'Type of AI result: tool, agent_log, or agent_response';

-- Add index for filtering by type
CREATE INDEX IF NOT EXISTS idx_ai_results_type ON ai_results(result_type);
#####

# migrations/009_add_handoff_fields.sql
#####
-- Migration: Add handoff fields to conversations table
-- Created at: 2024-01-29
-- Description: Adds agent_id and handoff_at columns for human handoff feature

ALTER TABLE conversations ADD COLUMN IF NOT EXISTS agent_id TEXT;
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS handoff_at TIMESTAMP WITH TIME ZONE;

-- Create index for performance on agent filtering
CREATE INDEX IF NOT EXISTS idx_conversations_agent_id ON conversations(agent_id);
CREATE INDEX IF NOT EXISTS idx_conversations_status_handoff ON conversations(status) WHERE status = 'human_handoff';
#####


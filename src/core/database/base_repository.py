"""
Base repository with common CRUD operations.
Provides reusable database operations for all repositories.
"""
from typing import TypeVar, Generic, Optional, List, Dict, Any, Union
from supabase import Client

from src.core.utils.custom_ulid import is_valid_ulid

from src.core.utils import get_logger

logger = get_logger(__name__)

T = TypeVar('T')


class BaseRepository(Generic[T]):
    """
    Base repository class with common CRUD operations.
    
    Supports both traditional integer IDs and ULID string IDs with
    automatic validation based on ID type.

    Attributes:
        table_name: Name of the database table
        model_class: Pydantic model class for this repository
        validates_ulid: Whether to validate ULID format (auto-detected)
    """
    
    def __init__(self, client: Client, table_name: str, model_class: type, validates_ulid: bool = True):
        """
        Initialize base repository.
        
        Args:
            client: Supabase client instance
            table_name: Name of the database table
            model_class: Pydantic model class
            validates_ulid: Whether to validate ULID format (default: True)
                           Set to False for tables using integer IDs
        """
        self.client = client
        self.table_name = table_name
        self.model_class = model_class
        self.validates_ulid = validates_ulid

    def _validate_id(self, id_value: Any, id_name: str = "id") -> None:
        """
        Validate ID value based on type.
        
        Args:
            id_value: ID value to validate
            id_name: Name of the ID field (for error messages)
            
        Raises:
            ValueError: If ULID validation is enabled and format is invalid
        """
        if not self.validates_ulid:
            return
        
        # Skip validation for None values
        if id_value is None:
            return
        
        # If it's a string, validate ULID format
        if isinstance(id_value, str):
            if not is_valid_ulid(id_value):
                raise ValueError(f'Invalid ULID format for {id_name}: {id_value}')
        # If it's an int, no validation needed (backward compatibility)
        elif not isinstance(id_value, int):
            logger.warning(
                f"Unexpected ID type for {id_name}",
                id_value=id_value,
                type=type(id_value).__name__
            )    

    def create(self, data: Dict[str, Any]) -> Optional[T]:
        """
        Create a new record.
        
        Note: Primary key (ULID) will be auto-generated by database trigger
        if not provided in data.
        
        Args:
            data: Data to insert
            
        Returns:
            Created model instance or None
        """
        try:
            # Validate any ULID fields in data if validation is enabled
            if self.validates_ulid:
                for key, value in data.items():
                    if isinstance(value, str) and len(value) == 26:
                        # Looks like a ULID, validate it
                        if 'id' in key.lower() and not is_valid_ulid(value):
                            raise ValueError(f'Invalid ULID format for {key}: {value}')
            
            result = self.client.table(self.table_name).insert(data).execute()
            if result.data:
                return self.model_class(**result.data[0])
            return None
        except Exception as e:
            logger.error(f"Error creating record in {self.table_name}", error=str(e))
            raise
    
    def find_by_id(self, id_value: Any, id_column: str = "id") -> Optional[T]:
        """
        Find a record by ID.
        
        Automatically validates ULID format if ID is a string and
        validation is enabled.
        
        Args:
            id_value: ID value to search for (int or ULID string)
            id_column: Name of the ID column
            
        Returns:
            Model instance or None
            
        Raises:
            ValueError: If ULID validation fails
        """
        # Validate ID if it's a string (ULID)
        self._validate_id(id_value, id_column)
        
        try:
            result = self.client.table(self.table_name)\
                .select("*")\
                .eq(id_column, id_value)\
                .execute()
            
            if result.data:
                return self.model_class(**result.data[0])
            return None
        except Exception as e:
            logger.error(
                f"Error finding record by {id_column} in {self.table_name}",
                error=str(e)
            )
            raise
    
    def find_all(self, limit: int = 100, offset: int = 0) -> List[T]:
        """
        Find all records with pagination.
        
        Args:
            limit: Maximum number of records to return
            offset: Number of records to skip
            
        Returns:
            List of model instances
        """
        try:
            result = self.client.table(self.table_name)\
                .select("*")\
                .range(offset, offset + limit - 1)\
                .execute()
            
            return [self.model_class(**item) for item in result.data]
        except Exception as e:
            logger.error(f"Error finding all records in {self.table_name}", error=str(e))
            raise
    
    def update(
        self, 
        id_value: Union[int, str], 
        data: Dict[str, Any], 
        id_column: str = "id"
    ) -> Optional[T]:
        """
        Update a record.
        
        Automatically validates ULID format if ID is a string and
        validation is enabled.
        
        Args:
            id_value: ID value of the record to update (int or ULID string)
            data: Data to update
            id_column: Name of the ID column
            
        Returns:
            Updated model instance or None
            
        Raises:
            ValueError: If ULID validation fails
        """
        # Validate ID if it's a string (ULID)
        self._validate_id(id_value, id_column)
        
        # Validate any ULID fields in update data
        if self.validates_ulid:
            for key, value in data.items():
                if isinstance(value, str) and len(value) == 26:
                    if 'id' in key.lower() and not is_valid_ulid(value):
                        raise ValueError(f'Invalid ULID format for {key}: {value}')
        
        try:
            result = self.client.table(self.table_name)\
                .update(data)\
                .eq(id_column, id_value)\
                .execute()
            
            if result.data:
                return self.model_class(**result.data[0])
            return None
        except Exception as e:
            logger.error(
                f"Error updating record in {self.table_name}",
                error=str(e)
            )
            raise
    
    def delete(
        self, 
        id_value: Union[int, str], 
        id_column: str = "id"
    ) -> bool:
        """
        Delete a record.
        
        Automatically validates ULID format if ID is a string and
        validation is enabled.
        
        Args:
            id_value: ID value of the record to delete (int or ULID string)
            id_column: Name of the ID column
            
        Returns:
            True if deleted, False otherwise
            
        Raises:
            ValueError: If ULID validation fails
        """
        # Validate ID if it's a string (ULID)
        self._validate_id(id_value, id_column)
        
        try:
            result = self.client.table(self.table_name)\
                .delete()\
                .eq(id_column, id_value)\
                .execute()
            
            return len(result.data) > 0
        except Exception as e:
            logger.error(
                f"Error deleting record from {self.table_name}",
                error=str(e)
            )
            raise
    
    def find_by(
        self, 
        filters: Dict[str, Any], 
        limit: int = 100
    ) -> List[T]:
        """
        Find records by multiple filters.
        
        Automatically validates ULID format for string values that look like IDs.
        
        Args:
            filters: Dictionary of column:value pairs to filter by
            limit: Maximum number of records to return
            
        Returns:
            List of model instances
            
        Raises:
            ValueError: If ULID validation fails
        """
        # Validate any ULID values in filters
        if self.validates_ulid:
            for key, value in filters.items():
                if isinstance(value, str) and len(value) == 26:
                    if 'id' in key.lower():
                        self._validate_id(value, key)
        
        try:
            query = self.client.table(self.table_name).select("*")
            
            for column, value in filters.items():
                query = query.eq(column, value)
            
            result = query.limit(limit).execute()
            
            return [self.model_class(**item) for item in result.data]
        except Exception as e:
            logger.error(
                f"Error finding records by filters in {self.table_name}",
                error=str(e)
            )
            raise
    
    def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Count records matching filters.
        
        Args:
            filters: Optional dictionary of column:value pairs to filter by
            
        Returns:
            Number of matching records
        """
        try:
            query = self.client.table(self.table_name).select("*", count="exact")
            
            if filters:
                # Validate any ULID values in filters
                if self.validates_ulid:
                    for key, value in filters.items():
                        if isinstance(value, str) and len(value) == 26:
                            if 'id' in key.lower():
                                self._validate_id(value, key)
                
                for column, value in filters.items():
                    query = query.eq(column, value)
            
            result = query.execute()
            return result.count or 0
        except Exception as e:
            logger.error(
                f"Error counting records in {self.table_name}",
                error=str(e)
            )
            raise

    def query_dynamic(
        self, 
        select_columns: List[str] = None, 
        filters: List[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """
        Execute a dynamic query with custom selection and filters.
        
        Args:
            select_columns: List of columns to select (default: ["*"])
            filters: List of filter dictionaries with keys:
                     - column: str
                     - operator: str (eq, gt, lt, gte, lte, ne, ct, in)
                     - value: Any
                     
        Returns:
            List of records as dictionaries
        """
        try:
            # Determine selection
            select_str = "*"
            if select_columns and select_columns != ["*"]:
                select_str = ", ".join(select_columns)
            
            query = self.client.table(self.table_name).select(select_str)
            
            # Apply filters
            if filters:
                for f in filters:
                    column = f.get("column")
                    operator = f.get("operator", "eq")
                    value = f.get("value")
                    
                    if not column:
                        continue
                        
                    # Basic validation for ULIDs in filters could be added here
                    
                    if operator == "eq":
                        query = query.eq(column, value)
                    elif operator == "gt":
                        query = query.gt(column, value)
                    elif operator == "lt":
                        query = query.lt(column, value)
                    elif operator == "gte":
                        query = query.gte(column, value)
                    elif operator == "lte":
                        query = query.lte(column, value)
                    elif operator == "ne":
                        query = query.neq(column, value)
                    elif operator == "ct" or operator == "ilike":
                        query = query.ilike(column, f"%{value}%")
                    elif operator == "in":
                        query = query.in_(column, value)
                    elif operator == "is":
                         query = query.is_(column, value)
            
            result = query.execute()
            return result.data
            
        except Exception as e:
            logger.error(
                f"Error executing dynamic query in {self.table_name}",
                error=str(e)
            )
            raise

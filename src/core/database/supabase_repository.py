"""
Supabase implementation of the Repository Pattern.
Provides CRUD operations using Supabase client.
"""

from typing import Any, Dict, Generic, List, Optional, TypeVar, Union

from supabase import Client

from src.core.database.interface import IDatabaseSession, IRepository
from src.core.utils import get_logger
from src.core.utils.custom_ulid import is_valid_ulid

logger = get_logger(__name__)

T = TypeVar("T")


class SupabaseRepository(Generic[T]):
    """
    Supabase implementation of IRepository.

    Supports both traditional integer IDs and ULID string IDs with
    automatic validation based on ID type.

    Attributes:
        table_name: Name of the database table
        model_class: Pydantic model class for this repository
        validates_ulid: Whether to validate ULID format (auto-detected)
    """

    def __init__(
        self,
        client: IDatabaseSession,
        table_name: str,
        model_class: type,
        validates_ulid: bool = True,
        exclude_on_create: Optional[List[str]] = None,
        primary_key: str = "id",
    ):
        """
        Initialize Supabase repository.

        Args:
            client: Database session (implementing IDatabaseSession)
            table_name: Name of the database table
            model_class: Pydantic model class
            validates_ulid: Whether to validate ULID format (default: True)
                           Set to False for tables using integer IDs
            primary_key: Name of the primary key column (default: "id")
        """
        self.client = client
        self.table_name = table_name
        self.model_class = model_class
        self.validates_ulid = validates_ulid
        self.exclude_on_create = exclude_on_create or []
        self.primary_key = primary_key

    def _validate_id(self, id_value: Any, id_name: Optional[str] = None) -> None:
        """
        Validate ID value based on type.

        Args:
            id_value: ID value to validate
            id_name: Name of the ID field (for error messages)

        Raises:
            ValueError: If ULID validation is enabled and format is invalid
        """
        if id_name is None:
            id_name = self.primary_key

        if not self.validates_ulid:
            return

        # Skip validation for None values
        if id_value is None:
            return

        # If it's a string, validate ULID format
        if isinstance(id_value, str):
            if not is_valid_ulid(id_value):
                raise ValueError(f"Invalid ULID format for {id_name}: {id_value}")
        # If it's an int, no validation needed (backward compatibility)
        elif not isinstance(id_value, int):
            logger.warning(
                f"Unexpected ID type for {id_name}",
                id_value=id_value,
                type=type(id_value).__name__,
            )

    def _serialize_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert complex types (like datetime) to JSON-serializable format."""
        serialized = {}
        for key, value in data.items():
            if hasattr(value, "isoformat"):  # datetime, date, time
                serialized[key] = value.isoformat()
            else:
                serialized[key] = value
        return serialized

    def create(self, data: Dict[str, Any]) -> Optional[T]:
        """
        Create a new record.

        Note: Primary key (ULID) will be auto-generated by database trigger
        if not provided in data.

        Args:
            data: Data to insert

        Returns:
            Created model instance or None
        """
        try:
            # Validate any ULID fields in data if validation is enabled
            if self.validates_ulid:
                for key, value in data.items():
                    if isinstance(value, str) and len(value) == 26:
                        # Looks like a ULID, validate it
                        if "id" in key.lower() and not is_valid_ulid(value):
                            raise ValueError(f"Invalid ULID format for {key}: {value}")

            if self.exclude_on_create:
                for col in self.exclude_on_create:
                    if col in data:
                        data = {**data}
                        data.pop(col, None)

            # Serialize data (e.g. datetime -> ISO string)
            serialized_data = self._serialize_data(data)

            result = self.client.table(self.table_name).insert(serialized_data).execute()
            if result.data:
                return self.model_class(**result.data[0])
            return None
        except Exception as e:
            logger.error(f"Error creating record in {self.table_name}", error=str(e))
            raise

    def find_by_id(self, id_value: Any, id_column: Optional[str] = None) -> Optional[T]:
        """
        Find a record by ID.

        Automatically validates ULID format if ID is a string and
        validation is enabled.

        Args:
            id_value: ID value to search for (int or ULID string)
            id_column: Name of the ID column (defaults to self.primary_key)

        Returns:
            Model instance or None

        Raises:
            ValueError: If ULID validation fails
        """
        if id_column is None:
            id_column = self.primary_key

        # Validate ID if it's a string (ULID)
        self._validate_id(id_value, id_column)

        try:
            result = (
                self.client.table(self.table_name)
                .select("*")
                .eq(id_column, id_value)
                .execute()
            )

            if result.data:
                return self.model_class(**result.data[0])
            return None
        except Exception as e:
            logger.error(
                f"Error finding record by {id_column} in {self.table_name}",
                error=str(e),
            )
            raise

    def find_all(self, limit: int = 100, offset: int = 0) -> List[T]:
        """
        Find all records with pagination.

        Args:
            limit: Maximum number of records to return
            offset: Number of records to skip

        Returns:
            List of model instances
        """
        try:
            result = (
                self.client.table(self.table_name)
                .select("*")
                .range(offset, offset + limit - 1)
                .execute()
            )

            return [self.model_class(**item) for item in result.data]
        except Exception as e:
            logger.error(
                f"Error finding all records in {self.table_name}", error=str(e)
            )
            raise

    def update(
        self,
        id_value: Union[int, str],
        data: Dict[str, Any],
        id_column: Optional[str] = None,
        current_version: Optional[int] = None,
    ) -> Optional[T]:
        """
        Update a record.

        Automatically validates ULID format if ID is a string and
        validation is enabled.

        Args:
            id_value: ID value of the record to update (int or ULID string)
            data: Data to update
            id_column: Name of the ID column (defaults to self.primary_key)

        Returns:
            Updated model instance or None

        Raises:
            ValueError: If ULID validation fails
        """
        if id_column is None:
            id_column = self.primary_key

        # Validate ID if it's a string (ULID)
        self._validate_id(id_value, id_column)

        # Validate any ULID fields in update data
        if self.validates_ulid:
            for key, value in data.items():
                if isinstance(value, str) and len(value) == 26:
                    if "id" in key.lower() and not is_valid_ulid(value):
                        raise ValueError(f"Invalid ULID format for {key}: {value}")

        try:
            if current_version is not None:
                if "version" not in data:
                    data = {**data, "version": current_version + 1}

            # Serialize data (e.g. datetime -> ISO string)
            serialized_data = self._serialize_data(data)

            query = self.client.table(self.table_name).update(serialized_data).eq(
                id_column, id_value
            )
            if current_version is not None:
                query = query.eq("version", current_version)

            result = query.execute()

            if result.data:
                return self.model_class(**result.data[0])
            return None
        except Exception as e:
            logger.error(f"Error updating record in {self.table_name}", error=str(e))
            raise

    def delete(self, id_value: Union[int, str], id_column: Optional[str] = None) -> bool:
        """
        Delete a record.

        Automatically validates ULID format if ID is a string and
        validation is enabled.

        Args:
            id_value: ID value of the record to delete (int or ULID string)
            id_column: Name of the ID column (defaults to self.primary_key)

        Returns:
            True if deleted, False otherwise

        Raises:
            ValueError: If ULID validation fails
        """
        if id_column is None:
            id_column = self.primary_key

        # Validate ID if it's a string (ULID)
        self._validate_id(id_value, id_column)

        try:
            result = (
                self.client.table(self.table_name)
                .delete()
                .eq(id_column, id_value)
                .execute()
            )

            return len(result.data) > 0
        except Exception as e:
            logger.error(f"Error deleting record from {self.table_name}", error=str(e))
            raise

    def find_by(self, filters: Dict[str, Any], limit: int = 100) -> List[T]:
        """
        Find records by multiple filters.

        Automatically validates ULID format for string values that look like IDs.

        Args:
            filters: Dictionary of column:value pairs to filter by
            limit: Maximum number of records to return

        Returns:
            List of model instances

        Raises:
            ValueError: If ULID validation fails
        """
        # Validate any ULID values in filters
        if self.validates_ulid:
            for key, value in filters.items():
                if isinstance(value, str) and len(value) == 26:
                    if "id" in key.lower():
                        self._validate_id(value, key)

        try:
            query = self.client.table(self.table_name).select("*")

            for column, value in filters.items():
                query = query.eq(column, value)

            result = query.limit(limit).execute()

            return [self.model_class(**item) for item in result.data]
        except Exception as e:
            logger.error(
                f"Error finding records by filters in {self.table_name}", error=str(e)
            )
            raise

    def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Count records matching filters.

        Args:
            filters: Optional dictionary of column:value pairs to filter by

        Returns:
            Number of matching records
        """
        try:
            query = self.client.table(self.table_name).select("*", count="exact")

            if filters:
                # Validate any ULID values in filters
                if self.validates_ulid:
                    for key, value in filters.items():
                        if isinstance(value, str) and len(value) == 26:
                            if "id" in key.lower():
                                self._validate_id(value, key)

                for column, value in filters.items():
                    query = query.eq(column, value)

            result = query.execute()
            return result.count or 0
        except Exception as e:
            logger.error(f"Error counting records in {self.table_name}", error=str(e))
            raise

    def query_dynamic(
        self, select_columns: List[str] = None, filters: List[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """
        Execute a dynamic query with custom selection and filters.

        Args:
            select_columns: List of columns to select (default: ["*"])
            filters: List of filter dictionaries with keys:
                     - column: str
                     - operator: str (eq, gt, lt, gte, lte, ne, ct, in)
                     - value: Any

        Returns:
            List of records as dictionaries
        """
        try:
            # Determine selection
            select_str = "*"
            if select_columns and select_columns != ["*"]:
                select_str = ", ".join(select_columns)

            query = self.client.table(self.table_name).select(select_str)

            # Apply filters
            if filters:
                for f in filters:
                    column = f.get("column")
                    operator = f.get("operator", "eq")
                    value = f.get("value")

                    if not column:
                        continue

                    # Basic validation for ULIDs in filters could be added here

                    if operator == "eq":
                        query = query.eq(column, value)
                    elif operator == "gt":
                        query = query.gt(column, value)
                    elif operator == "lt":
                        query = query.lt(column, value)
                    elif operator == "gte":
                        query = query.gte(column, value)
                    elif operator == "lte":
                        query = query.lte(column, value)
                    elif operator == "ne":
                        query = query.neq(column, value)
                    elif operator == "ct" or operator == "ilike":
                        query = query.ilike(column, f"%{value}%")
                    elif operator == "in":
                        query = query.in_(column, value)
                    elif operator == "is":
                        query = query.is_(column, value)

            result = query.execute()
            return result.data

        except Exception as e:
            logger.error(
                f"Error executing dynamic query in {self.table_name}", error=str(e)
            )
            raise
